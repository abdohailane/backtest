-- Migration script pour Supabase basé sur votre schéma PostgreSQL
-- Ce script crée les tables nécessaires dans Supabase

-- Extensions nécessaires
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- Table des clients
CREATE TABLE IF NOT EXISTS "public"."client" (
  "id" integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  "nom_entreprise" varchar(100) NOT NULL,
  "contact" varchar(100),
  "adresse" varchar(200),
  "code_postal" varchar(20),
  "ville" varchar(100),
  "telephone" varchar(20),
  "email" varchar(100),
  "reference_client" varchar(50),
  CONSTRAINT client_pkey PRIMARY KEY ("id")
);

-- Table des utilisateurs (utilise l'auth de Supabase)
CREATE TABLE IF NOT EXISTS "public"."user" (
  "id" integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  "nom" varchar(100) NOT NULL,
  "email" varchar(100) NOT NULL,
  "mot_de_passe" varchar(255) NOT NULL,
  "role" varchar(50) DEFAULT 'employe' NOT NULL,
  "date_creation" timestamp without time zone DEFAULT now() NOT NULL,
  CONSTRAINT user_pkey PRIMARY KEY ("id")
);

-- Table des types de sections
CREATE TABLE IF NOT EXISTS "public"."section_type" (
  "id" integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  "description" varchar(500) NOT NULL,
  CONSTRAINT section_type_pkey PRIMARY KEY ("id")
);

-- Table des sous-types de sections
CREATE TABLE IF NOT EXISTS "public"."sous_section_type" (
  "id" integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  "section_type_id" integer NOT NULL,
  "description" varchar(500) NOT NULL,
  CONSTRAINT sous_section_type_pkey PRIMARY KEY ("id")
);

-- Table des types d'items
CREATE TABLE IF NOT EXISTS "public"."item_type" (
  "id" integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  "soussection_type_id" integer NOT NULL,
  "description" varchar(500) NOT NULL,
  CONSTRAINT item_type_pkey PRIMARY KEY ("id")
);

-- Table des devis
CREATE TABLE IF NOT EXISTS "public"."devis" (
  "id" integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  "reference" varchar(50) NOT NULL,
  "date" date NOT NULL,
  "destinataire" varchar(100),
  "societe" varchar(100),
  "telephone" varchar(20),
  "v_ref" varchar(50),
  "objet" varchar(500),
  "nombre_pages" integer DEFAULT 1,
  "client_id" integer,
  "user_id" integer,
  "date_creation" timestamp without time zone DEFAULT now(),
  "date_modification" timestamp without time zone,
  "elements" text,
  "status" varchar(20),
  "email_sent_at" timestamp without time zone,
  CONSTRAINT devis_pkey PRIMARY KEY ("id")
);

-- Table des instances de sections
CREATE TABLE IF NOT EXISTS "public"."section_instance" (
  "id" integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  "devis_id" integer NOT NULL,
  "section_type_id" integer NOT NULL,
  "ordre" integer NOT NULL,
  CONSTRAINT section_instance_pkey PRIMARY KEY ("id")
);

-- Table des instances de sous-sections
CREATE TABLE IF NOT EXISTS "public"."sous_section_instance" (
  "id" integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  "section_instance_id" integer NOT NULL,
  "soussection_type_id" integer NOT NULL,
  "ordre" integer NOT NULL,
  CONSTRAINT sous_section_instance_pkey PRIMARY KEY ("id")
);

-- Table des instances d'items
CREATE TABLE IF NOT EXISTS "public"."item_instance" (
  "id" integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  "soussection_instance_id" integer NOT NULL,
  "item_type_id" integer NOT NULL,
  "ordre" integer NOT NULL,
  "quantite" numeric(10,2),
  CONSTRAINT item_instance_pkey PRIMARY KEY ("id")
);

-- Table des sous-types d'items
CREATE TABLE IF NOT EXISTS "public"."sous_item_type" (
  "id" integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  "item_type_id" integer NOT NULL,
  "description" varchar(500) NOT NULL,
  "unite" varchar(50),
  CONSTRAINT sous_item_type_pkey PRIMARY KEY ("id")
);

-- Table des instances de sous-items
CREATE TABLE IF NOT EXISTS "public"."sous_item_instance" (
  "id" integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  "item_instance_id" integer NOT NULL,
  "sousitem_type_id" integer NOT NULL,
  "ordre" integer NOT NULL,
  "unite" varchar(50),
  "quantite" numeric(10,2),
  "prix_unitaire" numeric(10,2),
  CONSTRAINT sous_item_instance_pkey PRIMARY KEY ("id")
);

-- Table des remarques
CREATE TABLE IF NOT EXISTS "public"."remarque" (
  "id" integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  "devis_id" integer NOT NULL,
  "element_type" varchar(50) NOT NULL,
  "element_id" integer NOT NULL,
  "contenu" text NOT NULL,
  "date_creation" timestamp without time zone DEFAULT now(),
  "date_modification" timestamp without time zone DEFAULT now(),
  "user_id" integer,
  CONSTRAINT remarque_pkey PRIMARY KEY ("id")
);

-- Table des codes de réinitialisation de mot de passe
CREATE TABLE IF NOT EXISTS "public"."password_reset_codes" (
  "id" integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  "email" varchar(255) NOT NULL,
  "code" varchar(10) NOT NULL,
  "created_at" timestamp without time zone DEFAULT now(),
  "expires_at" timestamp without time zone DEFAULT (now() + interval '15 minutes'),
  CONSTRAINT password_reset_codes_pkey PRIMARY KEY ("id")
);

-- Clés étrangères
ALTER TABLE "public"."devis" ADD CONSTRAINT "fk_devis_client_id_client_id"
  FOREIGN KEY ("client_id") REFERENCES "public"."client" ("id");
ALTER TABLE "public"."devis" ADD CONSTRAINT "fk_devis_user_id_user_id"
  FOREIGN KEY ("user_id") REFERENCES "public"."user" ("id");

ALTER TABLE "public"."item_instance" ADD CONSTRAINT "fk_item_instance_item_type_id_item_type_id"
  FOREIGN KEY ("item_type_id") REFERENCES "public"."item_type" ("id");
ALTER TABLE "public"."item_instance" ADD CONSTRAINT "fk_item_instance_soussection_instance_id_sous_section_instance_id"
  FOREIGN KEY ("soussection_instance_id") REFERENCES "public"."sous_section_instance" ("id") ON DELETE CASCADE;

ALTER TABLE "public"."item_type" ADD CONSTRAINT "fk_item_type_soussection_type_id_sous_section_type_id"
  FOREIGN KEY ("soussection_type_id") REFERENCES "public"."sous_section_type" ("id") ON DELETE CASCADE;

ALTER TABLE "public"."remarque" ADD CONSTRAINT "fk_remarque_devis_id_devis_id"
  FOREIGN KEY ("devis_id") REFERENCES "public"."devis" ("id") ON DELETE CASCADE;
ALTER TABLE "public"."remarque" ADD CONSTRAINT "fk_remarque_user_id_user_id"
  FOREIGN KEY ("user_id") REFERENCES "public"."user" ("id");

ALTER TABLE "public"."section_instance" ADD CONSTRAINT "fk_section_instance_devis_id_devis_id"
  FOREIGN KEY ("devis_id") REFERENCES "public"."devis" ("id") ON DELETE CASCADE;
ALTER TABLE "public"."section_instance" ADD CONSTRAINT "fk_section_instance_section_type_id_section_type_id"
  FOREIGN KEY ("section_type_id") REFERENCES "public"."section_type" ("id");

ALTER TABLE "public"."sous_item_instance" ADD CONSTRAINT "fk_sous_item_instance_item_instance_id_item_instance_id"
  FOREIGN KEY ("item_instance_id") REFERENCES "public"."item_instance" ("id") ON DELETE CASCADE;
ALTER TABLE "public"."sous_item_instance" ADD CONSTRAINT "fk_sous_item_instance_sousitem_type_id_sous_item_type_id"
  FOREIGN KEY ("sousitem_type_id") REFERENCES "public"."sous_item_type" ("id");

ALTER TABLE "public"."sous_item_type" ADD CONSTRAINT "fk_sous_item_type_item_type_id_item_type_id"
  FOREIGN KEY ("item_type_id") REFERENCES "public"."item_type" ("id") ON DELETE CASCADE;

ALTER TABLE "public"."sous_section_instance" ADD CONSTRAINT "fk_sous_section_instance_section_instance_id_section_instance_id"
  FOREIGN KEY ("section_instance_id") REFERENCES "public"."section_instance" ("id") ON DELETE CASCADE;
ALTER TABLE "public"."sous_section_instance" ADD CONSTRAINT "fk_sous_section_instance_soussection_type_id_sous_section_type_id"
  FOREIGN KEY ("soussection_type_id") REFERENCES "public"."sous_section_type" ("id");

ALTER TABLE "public"."sous_section_type" ADD CONSTRAINT "fk_sous_section_type_section_type_id_section_type_id"
  FOREIGN KEY ("section_type_id") REFERENCES "public"."section_type" ("id") ON DELETE CASCADE;

-- Index pour améliorer les performances
CREATE INDEX IF NOT EXISTS "ix_devis_client_id" ON "public"."devis" ("client_id");
CREATE INDEX IF NOT EXISTS "ix_devis_user_id" ON "public"."devis" ("user_id");
CREATE INDEX IF NOT EXISTS "ix_item_instance_item_type_id" ON "public"."item_instance" ("item_type_id");
CREATE INDEX IF NOT EXISTS "ix_item_instance_soussection_instance_id" ON "public"."item_instance" ("soussection_instance_id");
CREATE INDEX IF NOT EXISTS "ix_item_type_soussection_type_id" ON "public"."item_type" ("soussection_type_id");
CREATE INDEX IF NOT EXISTS "ix_remarque_devis_id" ON "public"."remarque" ("devis_id");
CREATE INDEX IF NOT EXISTS "ix_remarque_user_id" ON "public"."remarque" ("user_id");
CREATE INDEX IF NOT EXISTS "ix_section_instance_devis_id" ON "public"."section_instance" ("devis_id");
CREATE INDEX IF NOT EXISTS "ix_section_instance_section_type_id" ON "public"."section_instance" ("section_type_id");
CREATE INDEX IF NOT EXISTS "ix_sous_item_instance_item_instance_id" ON "public"."sous_item_instance" ("item_instance_id");
CREATE INDEX IF NOT EXISTS "ix_sous_item_instance_sousitem_type_id" ON "public"."sous_item_instance" ("sousitem_type_id");
CREATE INDEX IF NOT EXISTS "ix_sous_item_type_item_type_id" ON "public"."sous_item_type" ("item_type_id");
CREATE INDEX IF NOT EXISTS "ix_sous_section_instance_section_instance_id" ON "public"."sous_section_instance" ("section_instance_id");
CREATE INDEX IF NOT EXISTS "ix_sous_section_instance_soussection_type_id" ON "public"."sous_section_instance" ("soussection_type_id");
CREATE INDEX IF NOT EXISTS "ix_sous_section_type_section_type_id" ON "public"."sous_section_type" ("section_type_id");

-- Fonction pour mettre à jour date_modification automatiquement
CREATE OR REPLACE FUNCTION public.set_date_modification() RETURNS trigger AS $$
BEGIN
  NEW.date_modification := now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Triggers pour date_modification
CREATE TRIGGER trg_devis_set_date_modification
BEFORE UPDATE ON "public"."devis"
FOR EACH ROW EXECUTE FUNCTION public.set_date_modification();

CREATE TRIGGER trg_remarque_set_date_modification
BEFORE UPDATE ON "public"."remarque"
FOR EACH ROW EXECUTE FUNCTION public.set_date_modification();

-- Procédures stockées
-- sp_AddRemarque
CREATE OR REPLACE FUNCTION public.sp_add_remarque(
    p_devis_id integer,
    p_element_type varchar,
    p_element_id integer,
    p_contenu text,
    p_user_id integer
) RETURNS TABLE(rows_affected integer, action text, id integer)
LANGUAGE plpgsql
AS $$
DECLARE
    v_id integer;
BEGIN
    SELECT r.id INTO v_id
    FROM public.remarque r
    WHERE r.devis_id = p_devis_id AND r.element_type = p_element_type AND r.element_id = p_element_id
    LIMIT 1;

    IF v_id IS NOT NULL THEN
        UPDATE public.remarque
        SET contenu = p_contenu,
            date_modification = now(),
            user_id = p_user_id
        WHERE id = v_id;
        rows_affected := FOUND::int;
        action := 'updated';
        id := v_id;
        RETURN NEXT;
    ELSE
        INSERT INTO public.remarque (devis_id, element_type, element_id, contenu, user_id, date_creation, date_modification)
        VALUES (p_devis_id, p_element_type, p_element_id, p_contenu, p_user_id, now(), now())
        RETURNING id INTO v_id;
        rows_affected := 1;
        action := 'created';
        id := v_id;
        RETURN NEXT;
    END IF;
END;
$$;

-- sp_DeleteRemarque
CREATE OR REPLACE FUNCTION public.sp_delete_remarque(p_id integer)
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE v_rows integer;
BEGIN
  DELETE FROM public.remarque WHERE id = p_id;
  GET DIAGNOSTICS v_rows = ROW_COUNT;
  RETURN v_rows;
END; $$;

-- sp_DeleteRemarquesByDevis
CREATE OR REPLACE FUNCTION public.sp_delete_remarques_by_devis(p_devis_id integer)
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE v_rows integer;
BEGIN
  DELETE FROM public.remarque WHERE devis_id = p_devis_id;
  GET DIAGNOSTICS v_rows = ROW_COUNT;
  RETURN v_rows;
END; $$;

-- sp_GetRemarqueByElement
CREATE OR REPLACE FUNCTION public.sp_get_remarque_by_element(
    p_devis_id integer,
    p_element_type varchar,
    p_element_id integer
) RETURNS TABLE(
    id integer,
    element_type varchar,
    element_id integer,
    contenu text,
    date_creation timestamp without time zone,
    date_modification timestamp without time zone,
    user_id integer,
    nom_utilisateur varchar
) LANGUAGE sql AS $$
  SELECT r.id, r.element_type, r.element_id, r.contenu,
         r.date_creation, r.date_modification, r.user_id,
         u.nom AS nom_utilisateur
  FROM public.remarque r
  LEFT JOIN public."user" u ON r.user_id = u.id
  WHERE r.devis_id = p_devis_id
    AND r.element_type = p_element_type
    AND r.element_id = p_element_id
  ORDER BY r.element_type, r.element_id;
$$;

-- sp_GetRemarquesByDevis
CREATE OR REPLACE FUNCTION public.sp_get_remarques_by_devis(
    p_devis_id integer
) RETURNS TABLE(
    id integer,
    element_type varchar,
    element_id integer,
    contenu text,
    date_creation timestamp without time zone,
    date_modification timestamp without time zone,
    user_id integer,
    nom_utilisateur varchar
) LANGUAGE sql AS $$
  SELECT r.id, r.element_type, r.element_id, r.contenu,
         r.date_creation, r.date_modification, r.user_id,
         u.nom AS nom_utilisateur
  FROM public.remarque r
  LEFT JOIN public."user" u ON r.user_id = u.id
  WHERE r.devis_id = p_devis_id
  ORDER BY r.element_type, r.element_id;
$$;

-- Politiques RLS (Row Level Security)
ALTER TABLE "public"."client" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."user" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."section_type" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."sous_section_type" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."item_type" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."devis" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."section_instance" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."sous_section_instance" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."item_instance" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."sous_item_type" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."sous_item_instance" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."remarque" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."password_reset_codes" ENABLE ROW LEVEL SECURITY;

-- Politiques pour les utilisateurs
CREATE POLICY "Users can view own profile" ON "public"."user" FOR SELECT USING (auth.uid()::text = id::text);
CREATE POLICY "Users can update own profile" ON "public"."user" FOR UPDATE USING (auth.uid()::text = id::text);

-- Politiques pour les clients (tous les utilisateurs peuvent voir/modifier)
CREATE POLICY "All users can manage clients" ON "public"."client" FOR ALL USING (true);

-- Politiques pour les types de sections (tous les utilisateurs peuvent voir/modifier)
CREATE POLICY "All users can manage section types" ON "public"."section_type" FOR ALL USING (true);
CREATE POLICY "All users can manage sous section types" ON "public"."sous_section_type" FOR ALL USING (true);
CREATE POLICY "All users can manage item types" ON "public"."item_type" FOR ALL USING (true);
CREATE POLICY "All users can manage sous item types" ON "public"."sous_item_type" FOR ALL USING (true);

-- Politiques pour les devis
CREATE POLICY "Users can view own devis" ON "public"."devis" FOR SELECT USING (auth.uid()::text = user_id::text);
CREATE POLICY "Users can create devis" ON "public"."devis" FOR INSERT WITH CHECK (auth.uid()::text = user_id::text);
CREATE POLICY "Users can update own devis" ON "public"."devis" FOR UPDATE USING (auth.uid()::text = user_id::text);
CREATE POLICY "Users can delete own devis" ON "public"."devis" FOR DELETE USING (auth.uid()::text = user_id::text);

-- Politiques pour les instances (basées sur les devis)
CREATE POLICY "Users can manage own section instances" ON "public"."section_instance" FOR ALL USING (
  EXISTS (SELECT 1 FROM public.devis WHERE devis.id = section_instance.devis_id AND devis.user_id::text = auth.uid()::text)
);

CREATE POLICY "Users can manage own sous section instances" ON "public"."sous_section_instance" FOR ALL USING (
  EXISTS (SELECT 1 FROM public.section_instance si 
          JOIN public.devis d ON si.devis_id = d.id 
          WHERE si.id = sous_section_instance.section_instance_id AND d.user_id::text = auth.uid()::text)
);

CREATE POLICY "Users can manage own item instances" ON "public"."item_instance" FOR ALL USING (
  EXISTS (SELECT 1 FROM public.sous_section_instance ssi 
          JOIN public.section_instance si ON ssi.section_instance_id = si.id 
          JOIN public.devis d ON si.devis_id = d.id 
          WHERE ssi.id = item_instance.soussection_instance_id AND d.user_id::text = auth.uid()::text)
);

CREATE POLICY "Users can manage own sous item instances" ON "public"."sous_item_instance" FOR ALL USING (
  EXISTS (SELECT 1 FROM public.item_instance ii 
          JOIN public.sous_section_instance ssi ON ii.soussection_instance_id = ssi.id 
          JOIN public.section_instance si ON ssi.section_instance_id = si.id 
          JOIN public.devis d ON si.devis_id = d.id 
          WHERE ii.id = sous_item_instance.item_instance_id AND d.user_id::text = auth.uid()::text)
);

-- Politiques pour les remarques
CREATE POLICY "Users can view own devis remarques" ON "public"."remarque" FOR SELECT USING (
  EXISTS (SELECT 1 FROM public.devis WHERE devis.id = remarque.devis_id AND devis.user_id::text = auth.uid()::text)
);
CREATE POLICY "Users can create remarques for own devis" ON "public"."remarque" FOR INSERT WITH CHECK (
  EXISTS (SELECT 1 FROM public.devis WHERE devis.id = remarque.devis_id AND devis.user_id::text = auth.uid()::text)
);
CREATE POLICY "Users can update own remarques" ON "public"."remarque" FOR UPDATE USING (
  EXISTS (SELECT 1 FROM public.devis WHERE devis.id = remarque.devis_id AND devis.user_id::text = auth.uid()::text)
);
CREATE POLICY "Users can delete own remarques" ON "public"."remarque" FOR DELETE USING (
  EXISTS (SELECT 1 FROM public.devis WHERE devis.id = remarque.devis_id AND devis.user_id::text = auth.uid()::text)
);

-- Politiques pour les codes de réinitialisation (basées sur l'email)
CREATE POLICY "Users can manage own reset codes" ON "public"."password_reset_codes" FOR ALL USING (
  email = auth.jwt() ->> 'email'
); 